{"version":3,"sources":["../../src/component/AudioAnalyser/MediaRecorder.js"],"names":["convertWav","MediaRecorderFn","constraints","audio","props","startAudio","recorder","MediaRecorderClass","mediaRecorder","state","navigator","mediaDevices","getUserMedia","then","recordAudio","stream","catch","Error","err","resumeAudio","pauseAudio","pause","onpause","checkAndExecFn","pauseCallback","audioCtx","suspend","stopAudio","audioType","audioOptions","includes","stop","onstop","audioStream2Blob","stopCallback","audioChunk","initCanvas","compatibility","analyser","createAnalyser","audioBitsPerSecond","mimeType","MediaRecorder","ondataavailable","event","push","data","resume","start","onstart","e","startCallback","onresume","onerror","errorCallback","source","createMediaStreamSource","connect","renderCurve","promisifiedOldGUM","webkitGetUserMedia","mozGetUserMedia","Promise","reject","resolve","call","undefined","fn","type","cb","wavBlob","chunk","audioWav","fr","FileReader","readAsArrayBuffer","Blob","frOnload","buffer","target","result","decodeAudioData","DataView","onload","Target","window","AudioContext","webkitAudioContext"],"mappings":"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","file":"MediaRecorder.js","sourcesContent":["/**\r\n * @author j_bleach 2018/8/18\r\n * @describe 媒体记录（包含开始，暂停，停止等媒体流及回调操作）\r\n * @param Target 被装饰类（AudioAnalyser）\r\n */\r\nimport convertWav from \"./audioConvertWav\";\r\n\r\nconst MediaRecorderFn = Target => {\r\n    const constraints = {audio: true};\r\n    return class MediaRecorderClass extends Target {\r\n        static audioChunk = [] // 音频信息存储对象\r\n        static mediaRecorder = null // 媒体记录对象\r\n        static audioCtx = new (window.AudioContext || window.webkitAudioContext)(); // 音频上下文\r\n\r\n        constructor(props) {\r\n            super(props);\r\n            MediaRecorderClass.compatibility();\r\n            this.analyser = MediaRecorderClass.audioCtx.createAnalyser();\r\n        }\r\n\r\n        /**\r\n         * @author j_bleach 2018/08/02 17:06\r\n         * @describe 浏览器navigator.mediaDevices兼容性处理\r\n         */\r\n        static compatibility() {\r\n            const promisifiedOldGUM = (constraints) => {\r\n                // First get ahold of getUserMedia, if present\r\n                const getUserMedia =\r\n                    navigator.getUserMedia ||\r\n                    navigator.webkitGetUserMedia ||\r\n                    navigator.mozGetUserMedia;\r\n\r\n                // Some browsers just don't implement it - return a rejected promise with an error\r\n                // to keep a consistent interface\r\n                if (!getUserMedia) {\r\n                    return Promise.reject(\r\n                        new Error(\"getUserMedia is not implemented in this browser\")\r\n                    );\r\n                }\r\n                // Otherwise, wrap the call to the old navigator.getUserMedia with a Promise\r\n                return new Promise(function (resolve, reject) {\r\n                    getUserMedia.call(navigator, constraints, resolve, reject);\r\n                });\r\n            };\r\n\r\n            // Older browsers might not implement mediaDevices at all, so we set an empty object first\r\n            if (navigator.mediaDevices === undefined) {\r\n                navigator.mediaDevices = {};\r\n            }\r\n\r\n            // Some browsers partially implement mediaDevices. We can't just assign an object\r\n            // with getUserMedia as it would overwrite existing properties.\r\n            // Here, we will just add the getUserMedia property if it's missing.\r\n            if (navigator.mediaDevices.getUserMedia === undefined) {\r\n                navigator.mediaDevices.getUserMedia = promisifiedOldGUM;\r\n            }\r\n        }\r\n\r\n        /**\r\n         * @author j_bleach 2018/8/19\r\n         * @describe 验证函数，如果存在即执行\r\n         * @param fn: function 被验证函数\r\n         * @param e: object 事件对象 event object\r\n         */\r\n        static checkAndExecFn(fn, e) {\r\n            typeof fn === \"function\" && fn(e)\r\n        }\r\n\r\n        /**\r\n         * @author j_bleach 2018/8/19\r\n         * @describe 音频流转blob对象\r\n         * @param type: string 音频的mime-type\r\n         * @param cb: function 录音停止回调\r\n         */\r\n        static audioStream2Blob(type, audioOptions, cb) {\r\n            let wavBlob = null;\r\n            const chunk = MediaRecorderClass.audioChunk;\r\n            const audioWav = () => {\r\n                let fr = new FileReader();\r\n                fr.readAsArrayBuffer(new Blob(chunk, {type}))\r\n                let frOnload = (e) => {\r\n                    const buffer = e.target.result\r\n                    MediaRecorderClass.audioCtx.decodeAudioData(buffer).then(data => {\r\n                        wavBlob = new Blob([new DataView(convertWav(data, audioOptions))], {\r\n                            type: \"audio/wav\"\r\n                        })\r\n                        MediaRecorderClass.checkAndExecFn(cb, wavBlob);\r\n                    })\r\n                }\r\n                fr.onload = frOnload\r\n            }\r\n            switch (type) {\r\n                case \"audio/webm\":\r\n                    MediaRecorderClass.checkAndExecFn(cb, new Blob(chunk, {type}));\r\n                    break;\r\n                case \"audio/wav\":\r\n                    audioWav();\r\n                    break;\r\n                default:\r\n                    return void 0\r\n            }\r\n        }\r\n\r\n        /**\r\n         * @author j_bleach 2018/8/18\r\n         * @describe 开始录音\r\n         */\r\n        startAudio = () => {\r\n            const recorder = MediaRecorderClass.mediaRecorder;\r\n            if (!recorder || (recorder && recorder.state === \"inactive\")) {\r\n                navigator.mediaDevices.getUserMedia(constraints).then(stream => {\r\n                    this.recordAudio(stream);\r\n                }).catch(err => {\r\n                        throw new Error(\"getUserMedia failed:\", err);\r\n                    }\r\n                )\r\n                return false\r\n            }\r\n            if (recorder && recorder.state === \"paused\") {\r\n                MediaRecorderClass.resumeAudio();\r\n            }\r\n        }\r\n        /**\r\n         * @author j_bleach 2018/8/19\r\n         * @describe 暂停录音\r\n         */\r\n        pauseAudio = () => {\r\n            const recorder = MediaRecorderClass.mediaRecorder;\r\n            if (recorder && recorder.state === \"recording\") {\r\n                recorder.pause();\r\n                recorder.onpause = () => {\r\n                    MediaRecorderClass.checkAndExecFn(this.props.pauseCallback);\r\n                }\r\n                MediaRecorderClass.audioCtx.suspend();\r\n            }\r\n        }\r\n        /**\r\n         * @author j_bleach 2018/8/18\r\n         * @describe 停止录音\r\n         */\r\n        stopAudio = () => {\r\n            const {audioType, audioOptions} = this.props;\r\n            const recorder = MediaRecorderClass.mediaRecorder;\r\n            if (recorder && [\"recording\", \"paused\"].includes(recorder.state)) {\r\n                recorder.stop();\r\n                recorder.onstop = () => {\r\n                    MediaRecorderClass.audioStream2Blob(audioType, audioOptions, this.props.stopCallback);\r\n                    MediaRecorderClass.audioChunk = []; // 结束后，清空音频存储\r\n                }\r\n                MediaRecorderClass.audioCtx.suspend();\r\n                this.initCanvas();\r\n            }\r\n        }\r\n\r\n        /**\r\n         * @author j_bleach 2018/8/18\r\n         * @describe mediaRecorder音频记录\r\n         * @param stream: binary data 音频流\r\n         */\r\n        recordAudio(stream) {\r\n            const {audioBitsPerSecond, mimeType} = this.props;\r\n            MediaRecorderClass.mediaRecorder = new MediaRecorder(stream, {audioBitsPerSecond, mimeType});\r\n            MediaRecorderClass.mediaRecorder.ondataavailable = (event) => {\r\n                MediaRecorderClass.audioChunk.push(event.data);\r\n            }\r\n            MediaRecorderClass.audioCtx.resume();\r\n            MediaRecorderClass.mediaRecorder.start();\r\n            MediaRecorderClass.mediaRecorder.onstart = (e) => {\r\n                MediaRecorderClass.checkAndExecFn(this.props.startCallback, e);\r\n            }\r\n            MediaRecorderClass.mediaRecorder.onresume = (e) => {\r\n                MediaRecorderClass.checkAndExecFn(this.props.startCallback, e);\r\n            }\r\n            MediaRecorderClass.mediaRecorder.onerror = (e) => {\r\n                MediaRecorderClass.checkAndExecFn(this.props.errorCallback, e);\r\n            }\r\n            const source = MediaRecorderClass.audioCtx.createMediaStreamSource(stream);\r\n            source.connect(this.analyser);\r\n            this.renderCurve(this.analyser);\r\n        }\r\n\r\n        /**\r\n         * @author j_bleach 2018/8/19\r\n         * @describe 恢复录音\r\n         */\r\n        static resumeAudio() {\r\n            MediaRecorderClass.audioCtx.resume();\r\n            MediaRecorderClass.mediaRecorder.resume();\r\n        }\r\n    }\r\n}\r\nexport default MediaRecorderFn;"]}